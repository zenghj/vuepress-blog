(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{438:function(t,e,_){t.exports=_.p+"assets/img/cdn-header1.c946bd7a.png"},439:function(t,e,_){t.exports=_.p+"assets/img/cdn-header.75991189.png"},487:function(t,e,_){"use strict";_.r(e);var n=_(9),v=Object(n.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("p",[t._v("使用阿里云cdn服务托管整个页面的前端资源（html + css + js），部署更新html资源之后，发现客户端（Android webview）访问页面时页面没有更新到新的页面。查看html资源的响应头如下：")]),t._v(" "),n("p",[n("img",{attrs:{src:_(438),alt:""}})]),t._v(" "),n("p",[t._v("按理来说，是可以通过"),n("code",[t._v("last-modified")]),t._v("字段使用协商缓存策略的，更新html资源之后，用户应该能够拿到新的hmtl资源。")]),t._v(" "),n("p",[t._v("通过"),n("a",{attrs:{href:"https://www.jianshu.com/p/4e5049101271",target:"_blank",rel:"noopener noreferrer"}},[t._v("查资料"),n("OutboundLink")],1),t._v("发现，android webview的缓存策略好像和平常的认知有点不同")]),t._v(" "),n("p",[t._v("webview支持5中缓存模式：")]),t._v(" "),n("ul",[n("li",[n("p",[t._v("LOAD_CACHE_ONLY: 不发网络请求资源，只读取缓存。")])]),t._v(" "),n("li",[n("p",[t._v("LOAD_DEFAULT: 根据cache-control或者Last-Modified决定是否从网络上取数据。默认采用该方案")])]),t._v(" "),n("li",[n("p",[t._v("LOAD_CACHE_NORMAL: 新版本已经废弃，同LOAD_DEFAULT")])]),t._v(" "),n("li",[n("p",[t._v("LOAD_NO_CACHE: 不使用缓存，只从网络获取数据。")])]),t._v(" "),n("li",[n("p",[t._v("LOAD_CACHE_ELSE_NETWORK:只要本地有，无论是否过期，或者no-cache，都使用缓存中的数据。本地没有缓存时才从网络上获取。")])])]),t._v(" "),n("p",[t._v("在没有配置"),n("code",[t._v("cache-control")]),t._v("字段的情况下，浏览器会使用启发式算法策略：通过采用请求响应头中的Date减轻Last-Modified的值的10%作为缓存时间，即在这10%的时间内不发请求，直接使用缓存资源。")]),t._v(" "),n("p",[t._v("所以会出现更新html资源之后依然没有访问到新的页面。")]),t._v(" "),n("p",[t._v("解决方式就是给html资源配置"),n("code",[t._v("cache-control: no-cache")]),t._v("响应头")]),t._v(" "),n("p",[n("img",{attrs:{src:_(439),alt:""}})])])}),[],!1,null,null,null);e.default=v.exports}}]);